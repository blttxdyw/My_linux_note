进程创建
	#include <unistd.h>

	（1）pid_t fork(void);
		- 创建新进程，失败时返回-1
		- 成功时父进程返回子进程的进程号，子进程返回0
		- 通过fork的返回值区分父进程和子进程

		
	（2）getpid()
		获取当前进程的进程号

父子进程：
	- 子进程继承了父进程的内容（父进程的pid,ppid等和子进程不一样）

	- 父子进程有独立的地址空间，互补影响
	
	- 若父进程先结束
		- 子进程成为孤儿进程，被init 进程收养（init进程是内核创建的第一个进程，pid=1）
		- 子进程变成后台进程

	- 若子进程先结束
		- 父进程如果没有及时回收，子进程会变成僵尸进程


思考？
	子进程从何处开始运行？
		从fork()的下一条语句

	父子进程谁先执行？
		不确定，看内核的调度情况

	父进程能否多次调用fork？    子进程？
		可以	可以


进程结束：
	#include <stdlib.h>
	#include <unistd.h>

	（3）void exit(int status);

	（4）void _exit(int status);
		- 结束当前的进程并将status返回
		exit结束进程时会刷新（流）缓冲区，而_exit不会